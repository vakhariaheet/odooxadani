# Module M05: Contract & E-Signature

## Overview

**Estimated Time:** 1.5hr

**Complexity:** Complex

**Type:** Full-stack

**Risk Level:** Medium

**Dependencies:** F01 (Proposal Management)

## Problem Context

After a client accepts a proposal, freelancers need to generate a contract and collect a digital signature. This module provides contract generation from proposals, a simple canvas-based e-signature interface, and signature verification.

## Technical Requirements

### Backend Tasks

- [ ] **Handler File:** Create `handlers/generateContract.ts` with typed handler
  - Import: `AuthenticatedAPIGatewayEvent`, `withRbacOwn`, `successResponse`, `handleAsyncError`
  - Pattern: `baseHandler` function + `export const handler = withRbacOwn(baseHandler, 'contracts', 'create')`
  - Generate contract from accepted proposal
  - Create contract record with status 'pending_signature'
  - Generate shareable signing link

- [ ] **Handler File:** Create `handlers/getContract.ts` with typed handler
  - Import: `AuthenticatedAPIGatewayEvent`, `withRbac`, `successResponse`, `handleAsyncError`
  - Pattern: `baseHandler` function + `export const handler = withRbac(baseHandler, 'contracts', 'read')`
  - Support both freelancer and client access
  - Return contract with signature status

- [ ] **Handler File:** Create `handlers/signContract.ts` with typed handler
  - Import: `AuthenticatedAPIGatewayEvent`, `withRbac`, `successResponse`, `handleAsyncError`
  - Pattern: `baseHandler` function + `export const handler = withRbac(baseHandler, 'contracts', 'update')`
  - Accept signature data (base64 image from canvas)
  - Store signature in S3
  - Update contract status to 'signed'
  - Record signer info and timestamp
  - Send confirmation emails to both parties

- [ ] **Handler File:** Create `handlers/listContracts.ts` with typed handler
  - Import: `AuthenticatedAPIGatewayEvent`, `withRbacOwn`, `successResponse`, `handleAsyncError`
  - Pattern: `baseHandler` function + `export const handler = withRbacOwn(baseHandler, 'contracts', 'read')`
  - List contracts for authenticated user
  - Support filtering by status

- [ ] **Handler File:** Create `handlers/downloadContract.ts` with typed handler
  - Import: `AuthenticatedAPIGatewayEvent`, `withRbac`, `successResponse`, `handleAsyncError`
  - Pattern: `baseHandler` function + `export const handler = withRbac(baseHandler, 'contracts', 'read')`
  - Generate PDF with contract and signature
  - Return presigned S3 URL for download

- [ ] **Function Config:** Create YAML files for each handler
  - `functions/generateContract.yml` - POST /api/contracts/generate
  - `functions/getContract.yml` - GET /api/contracts/{id}
  - `functions/signContract.yml` - POST /api/contracts/{id}/sign
  - `functions/listContracts.yml` - GET /api/contracts
  - `functions/downloadContract.yml` - GET /api/contracts/{id}/download

- [ ] **Service Layer:** Business logic in `services/ContractService.ts`
  - Create service class with methods for contract operations
  - Instantiate service at module level: `const contractService = new ContractService()`
  - Methods: generateContract, getContract, signContract, listContracts, downloadContract
  - Generate contract from proposal data
  - Store signature images in S3
  - Generate PDF with puppeteer or jsPDF

- [ ] **Type Definitions:** Add types to `types.ts` for requests/responses
  - ContractStatus: 'pending_signature' | 'signed' | 'expired' | 'cancelled'
  - Contract interface with all fields
  - SignatureData interface
  - GenerateContractRequest, SignContractRequest types

- [ ] **RBAC Verification:** Verify `config/permissions.ts` includes this module
  - Module 'contracts' should be in `ALL_MODULES` list
  - Freelancer role has createOwn, readOwn, updateOwn
  - Client role has readOwn, updateOwn (for signing)
  - Admin role has full access

- [ ] **AWS Service Integration:** Use shared/clients/\* wrappers
  - DynamoDB: `import { dynamodb } from '../../../shared/clients/dynamodb'`
  - S3: `import { s3Client } from '../../../shared/clients/s3'` (for signature storage)
  - SES: `import { sesClient } from '../../../shared/clients/ses'` (for notifications)
  - **NEVER import @aws-sdk packages directly**

- [ ] **Error Handling:** Use `handleAsyncError()` and `commonErrors.*` consistently

### Frontend Tasks

- [ ] **Pages/Components:**
  - `pages/contracts/ContractListPage.tsx` - List all contracts
  - `pages/contracts/ContractViewPage.tsx` - View contract details
  - `pages/contracts/ContractSignPage.tsx` - Signing interface for clients
  - `components/contracts/ContractList.tsx` - Table component
  - `components/contracts/ContractPreview.tsx` - Contract preview
  - `components/contracts/SignatureCanvas.tsx` - Canvas for drawing signature
  - `components/contracts/SignatureVerification.tsx` - Display signed contract

- [ ] **shadcn Components:**
  - Button, Card, Dialog, Badge, Tabs

- [ ] **API Integration:**
  - Create `hooks/useContracts.ts` with React Query
  - Methods: useContracts, useContract, useGenerateContract, useSignContract, useDownloadContract
  - Handle loading/error states
  - Invalidate queries after mutations

- [ ] **State Management:**
  - React Query for server state
  - Local state for signature canvas, drawing state

- [ ] **Routing:**
  - `/contracts` - List page
  - `/contracts/:id` - View page
  - `/contracts/:id/sign` - Signing page (public link for clients)

### Database Schema (Single Table)

```
PK: FREELANCER#{freelancerId} | SK: CONTRACT#{contractId}
GSI1PK: CLIENT#{clientId} | GSI1SK: CONTRACT#{contractId}
GSI2PK: PROPOSAL#{proposalId} | GSI2SK: CONTRACT#{contractId}

Fields:
- contractId: string (unique ID)
- contractNumber: string (CON-2024-001)
- freelancerId: string (owner)
- clientId: string
- clientName: string
- clientEmail: string
- proposalId: string (source proposal)
- title: string
- content: string (contract text/terms)
- scopeOfWork: string
- amount: number
- currency: string
- startDate: string (ISO date)
- endDate?: string (ISO date)
- status: 'pending_signature' | 'signed' | 'expired' | 'cancelled'
- signatureUrl?: string (S3 URL)
- signedBy?: string (client name)
- signedAt?: string (ISO timestamp)
- signerIp?: string
- shareableLink: string (for client signing)
- expiresAt: string (ISO timestamp, e.g., 30 days)
- createdAt: string (ISO timestamp)
- updatedAt: string (ISO timestamp)
```

## External Services

### Puppeteer or jsPDF (PDF Generation)

- **Purpose:** Generate PDF contracts with signatures
- **Setup Steps:**
  1. Choose library: `npm install puppeteer` OR `npm install jspdf`
  2. For puppeteer: Install chrome-aws-lambda for Lambda compatibility
  3. For jsPDF: Simpler, no browser needed
- **Environment Variables:** None required
- **NPM Package:** `npm install jspdf` (recommended for hackathon - simpler)
- **Code Pattern:**

  ```typescript
  import jsPDF from 'jspdf';

  const doc = new jsPDF();
  doc.text('Contract', 20, 20);
  doc.text(contractContent, 20, 40);
  doc.addImage(signatureBase64, 'PNG', 20, 200, 50, 20);
  const pdfBuffer = doc.output('arraybuffer');
  ```

### S3 (Signature Storage)

- **Purpose:** Store signature images and generated PDFs
- **Setup Steps:**
  1. Use existing S3 client wrapper
  2. Create bucket or use existing one
  3. Configure CORS for uploads
- **Environment Variables:** `S3_BUCKET_NAME`
- **Code Pattern:** Use `s3Client` from shared/clients/s3

## Implementation Guide

### Step 0: Study Phase (MANDATORY - Do This First)

**BEFORE writing any code, spend 15-20 minutes studying:**

1. **Review Guidelines:**

   ```bash
   cat guidelines/QUICK_REFERENCE.md
   cat guidelines/CODING_GUIDELINES.md
   ```

2. **Study S3 Client Wrapper:**

   ```bash
   cat backend/src/shared/clients/s3.ts
   ```

3. **Study Proposal Module:**

   ```bash
   cat backend/src/modules/proposals/services/ProposalService.ts
   ```

4. **Research Canvas Signature:**
   - Look for React signature canvas libraries
   - Consider: react-signature-canvas or custom canvas implementation

### Step 1: Backend Implementation

**File Structure:**

```
backend/src/modules/contracts/
├── handlers/
│   ├── generateContract.ts
│   ├── getContract.ts
│   ├── signContract.ts
│   ├── listContracts.ts
│   └── downloadContract.ts
├── functions/
│   ├── generateContract.yml
│   ├── getContract.yml
│   ├── signContract.yml
│   ├── listContracts.yml
│   └── downloadContract.yml
├── services/
│   └── ContractService.ts
└── types.ts
```

**Implementation Order:**

1. Create types.ts
2. Create ContractService.ts (start with generate, then sign, download)
3. Create handlers
4. Create YAML configs
5. Update serverless.yml

### Step 2: Frontend Implementation

**File Structure:**

```
client/src/
├── pages/contracts/
│   ├── ContractListPage.tsx
│   ├── ContractViewPage.tsx
│   └── ContractSignPage.tsx
├── components/contracts/
│   ├── ContractList.tsx
│   ├── ContractPreview.tsx
│   ├── SignatureCanvas.tsx
│   └── SignatureVerification.tsx
├── hooks/
│   └── useContracts.ts
└── types/
    └── contract.ts
```

**Implementation Order:**

1. Install signature library: `npm install react-signature-canvas`
2. Create types/contract.ts
3. Create hooks/useContracts.ts
4. Create SignatureCanvas component
5. Create ContractSignPage (most important for demo)
6. Create ContractList and other components
7. Add routes to App.tsx

### Step 3: Serverless Configuration

**Update serverless.yml:**

```yaml
functions:
  # Contract & E-Signature
  - ${file(src/modules/contracts/functions/generateContract.yml)}
  - ${file(src/modules/contracts/functions/getContract.yml)}
  - ${file(src/modules/contracts/functions/signContract.yml)}
  - ${file(src/modules/contracts/functions/listContracts.yml)}
  - ${file(src/modules/contracts/functions/downloadContract.yml)}
```

**Add environment variables:**

```yaml
provider:
  environment:
    S3_BUCKET_NAME: ${self:custom.s3BucketName}
```

### Step 4: Integration

- [ ] Test contract generation from proposal
- [ ] Test signature canvas drawing
- [ ] Test signature upload to S3
- [ ] Test PDF generation with signature
- [ ] Test email notifications

## LLM Prompts for Implementation

**Backend Handler Creation:**

```
Create Lambda handlers for contract and e-signature functionality.

Requirements:
- Use AuthenticatedAPIGatewayEvent
- generateContract: Create contract from proposal
- signContract: Accept signature data, store in S3, update status
- downloadContract: Generate PDF with jsPDF, include signature
- Use S3 client wrapper for signature storage
- Send email notifications on signing
```

**Service Layer Creation:**

```
Create ContractService class with contract and signature logic.

Requirements:
- Generate contract from proposal data
- Store signature images in S3 using s3Client wrapper
- Generate PDF with jsPDF (include contract text and signature)
- Validate signature data (base64 image)
- Send email notifications to both parties
```

**Frontend Signature Component:**

```
Create SignatureCanvas component using react-signature-canvas.

Requirements:
- Canvas for drawing signature
- Clear button to reset
- Save button to submit signature
- Convert canvas to base64 image
- Preview signed signature
- Responsive design for mobile
```

## Acceptance Criteria

- [ ] Freelancers can generate contracts from accepted proposals
- [ ] Clients receive email with signing link
- [ ] Clients can draw signature on canvas
- [ ] Signature is stored in S3
- [ ] Contract status updates to 'signed' after signing
- [ ] Both parties receive confirmation email
- [ ] Signed contract PDF can be downloaded
- [ ] PDF includes contract text and signature image
- [ ] **Demo Ready:** Can generate contract and sign it in 60 seconds
- [ ] **Full-Stack Working:** End-to-end signing workflow
- [ ] **Lambda Compatible:** All handlers work in serverless
- [ ] **Error Handling:** Graceful error handling
- [ ] **Mobile Responsive:** Signature canvas works on mobile

## Testing Checklist

- [ ] **Manual API Testing:**
  - Generate contract: `POST /api/contracts/generate`
  - Get contract: `GET /api/contracts/{id}`
  - Sign contract: `POST /api/contracts/{id}/sign`
  - Download contract: `GET /api/contracts/{id}/download`
  - Verify signature stored in S3
  - Verify PDF generation works
- [ ] **Frontend Testing:**
  - Signature canvas draws smoothly
  - Clear button works
  - Signature submits successfully
  - PDF download works
  - Email notifications sent
- [ ] **Integration:** End-to-end signing workflow
- [ ] **Edge Cases:**
  - Empty signature (validation)
  - Expired contract link
  - Already signed contract

## Deployment Checklist

- [ ] **Code Review:** Self-review completed
- [ ] **Serverless Config:** Added function imports
- [ ] **RBAC Config:** Verified permissions
- [ ] **S3 Bucket:** Created or configured
- [ ] **Environment Variables:** S3_BUCKET_NAME set
- [ ] **NPM Packages:** jspdf, react-signature-canvas installed
- [ ] **Testing:** Manual testing completed

## Troubleshooting Guide

### Common Issues

1. **Signature Not Saving**
   - Check S3 permissions
   - Verify base64 encoding
   - Check S3 client wrapper usage
   - Verify bucket name in environment

2. **PDF Generation Fails**
   - Check jsPDF is installed
   - Verify signature image format
   - Test with sample data
   - Check Lambda memory limits

3. **Canvas Not Working on Mobile**
   - Ensure touch events are handled
   - Test on actual mobile device
   - Check canvas size and scaling
   - Use react-signature-canvas library

4. **Email Not Sending**
   - Check SES configuration
   - Verify email addresses
   - Check email template
   - Use test mode for development

## Related Modules

- **Depends On:** F01 (Proposal Management)
- **Enables:** Legal contract workflow
- **Conflicts With:** None
